nodejs被诋毁的部分原因：
1.单线程带来的硬件资源利用不足与异常导致整个应用退出而带来对于稳定性和健壮性的质疑
	备注：HTML5规范提倡的web worker可以帮助我们很好处理该问题，nodejs借鉴其提供了child_process模块以便于进程复制以及进程间通信机制
2.异步I/O不符合传统线性思维以及函数嵌套带来的噩梦
3.异常的捕获问题（try{}catch(){}机制无效）

偏函数：（jquery中的应用）
e.g:
	var isType = function(type){
		return function(data){
			return Object.prototype.toString.call(data) == '[object '+ type +']';
		};
	}
	var isArray = isType('Array');
	isArray(['derick']);
e.g:
	var after = function(times,cb){
		if(times <= 0){return cb();}
		return function(){
			if(--times < 1){
				return cb.apply(this,arguments);
			}
		}
	};

异步编程解决方案：
1.sub/pub(事件发布/订阅模式)
2.promise/deferred模式（promise用于事件注册添加自定义逻辑作用于外部，可变；deferred用于择机触发事件和状态变化作用于内部，不可变）
3.流程控制库

/*
	@ sub/pub模式(nodejs原生提供模块)
*/
	var events = require('events').EventEmitter,
		eventIns = new events();
	eventIns.on('eventName',cb);
	eventIns.emit('eventName',data);
	
	e.g.业务场景：雪崩问题
	
	var proxy = new events.EventEmitter(),
		status = 'ready';
	var select = function(cb){
		proxy.once('selected',cb);
		if(status == 'ready'){
			status = 'pending';
			db.select('sql',function(data){
				proxy.emit('selected',data);
				status = 'ready';
			});
		}
	};
	
	e.g.参考github中connect_pool.js
	
	//多异步间的协作方案（即sub与pub间是一对多的关系）
	e.g.利用上述偏函数after
	function after(times,cb){
		var count =0, result = {};
		return function(key,value){
			result[key] = value;
			count++;
			if(count == times){
				return cb.call(this,result);
			}
		};
	}
	proxy.on('done',after());
	proxy.emit('done',data1);
	proxy.emit('done',data2);
	proxy.emit('done',data2);
	
/*
	@ promise/deferred模式
	promise存在三种状态：未完成，完成，失败
*/
	e.g.
	function Promise(){
		EventEmitter.call(this);
	}
	Promise.prototype.then = function(successHandler,errorHandler,progressHandler){
		if(typeof successHandler == 'function'){
			this.once('success',successHandler);
		}
		if(typeof errorHandler == 'function'){
			this.once('error',errorHandler);
		}
		if(typeof progressHandler == 'function'){
			this.once('progress',progressHandler);
		}
		return this;
	};
	
	function Deferred(){
		this.state = 'unFulfilled';
		this.promise = new Promise();
	}
	
	Deferred.prototype.resolve = function(data){
		this.state = 'success';
		this.promise.emit('success',data);
	};
	
	Deferred.prototype.reject = function(err){
		this.state = 'error';
		this.promise.emit('error',err);
	};
	
	Deferred.prototype.progress = function(){
		this.promise.emit('progress');
	};
	
	//针对上述模式，进行具体业务场景封装
	var promiseHttpServer = function(){
		var deferred = new Deferred(),
			chunks = [],size = 0;
		res.on('data',function(chunk){
			size += chunk.length;
			chunks.push(chunk);
			deferred.progress();
		});
		res.on('end',function(){
			deferred.resolve(Buffer.concat(chunks,size).toString());
		});
		res.on('error',function(err){
			deferred.reject(err);
		});
		return deferred.promise;
	}
	promiseHttpServer(res).then(function(){}.....);
	
	//Q包对Promise/A规范的实现,针对常见异步I/O进行封装
	Deferred.prototype.makeNodeResolver = function(){
		var self = this;
		return function(error,value){
			if(error){
				self.reject(error);
			}
			else if(arguments.length > 2){
				self.resolve(array_slice(arguments,1));
			}
			else{
				self.resolve(value);
			}
		};
	};
	var readFile = function(){
		var defer = Q.defer();
		fs.readFile(file,encoding,defer.makeNodeResolver());
		return defer.promise;
	};
	readFile(filename).then(function(){}...);
	




