
Node三大特点密不可分：

	Node保持了javascript在浏览器中单线程的特点，这样避免了多线程状态同步，上线文切换以及内存分配等问题，但这
	同时也注定了其自身其他特点出现的必然性。首先就是异步io，作为服务端平台，需要不间断接受新的请求并予以响应，
	nodejs也只有通过异步io才能保证整个应用不会因为io的阻塞导致执行的“停顿”（当然这里暂时先不讨论计算密集型应用
	的问题）。然而异步io如何实现，结合浏览器端javascript的运用我们发现事件和回调函数的结合是最佳的实现方式，事件
	可以让程序员只需要关注固定的事件节点并且可以很好的解耦代码，多异步协作的场景下也可以通过事件的相互配合来实现，
	（当然多异步协作问题也有其他的解决方案比如Pub/Sub,Promise/Deferred等）,而对于回调函数前端工程师再熟悉不过了，
	浏览器中通过ajax发起的异步请求就是通过回调的方式来接受服务端返回数据。
	
	
单线程带来的问题：
	
	1.浏览器端javascript和UI共用一个线程，所以javascript的执行将会导致UI渲染的暂停。而作为服务端的nodejs,长时间
	的cpu占用将会导致后续的异步io发不出调用，系统底层已经完成的异步io对应回调也得不到执行。html5提出了web workers
	规范给了我们很好的解决方案，通过它我们可以创建工作线程来将计算密集型的工作交给工作线程进行处理以避免javascript的
	执行导致UI渲染阻塞的问题。而对于nodejs也借鉴了该规范来解决单线程大量计算的问题：child_process，通过创建子进程
	我们可以实现master-worker的主从工作模式，进程之间通过事件的方式进行通信以传递数据。进而充分利用多核cpu，这也是
	对硬件资源的充分利用。
	
	
异步io：

	单线程符合编程人员的顺序思维方式，但串行的问题在于任何一个略慢的任务都会导致后续执行的代码被阻塞。在计算机资源中
	cpu和i/o之间是可以并行进行的。但同步带来的问题是i/o的进行会让后续任务等待，从而造成硬件资源不能很好被利用。我们
	在这里可能会听到许多的混淆概念比如阻塞，非阻塞，同步，异步等，这里特别说明下：
	
	操作系统内核对于i/o只有两种方式：阻塞和非阻塞。在调用阻塞i/o时应用程序需要等到调用结束才返回结果，以读取磁盘文件
	为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存后算结束。阻塞i/o导致cpu等待，cpu的处理能力得不到充分利用。
	为了提高cpu利用能力，系统内核提供了非阻塞I/O。非阻塞i/o跟阻塞i/o最大的差别就是调用后立即返回（注意这里返回的并不
	是实际需要的最终数据），这样cpu可以用来处理其他事务。但要注意的是此时i/o返回的不是实际需要的数据，那为了获取完整
	的数据，cpu就必须不停轮询调用i/o来确认是否最终完成，当然具体轮询的实现有差异（轮询i/o状态，文件描述符，epoll等），
	轮询技术满足了非阻塞i/o确保获取完整数据的需求，但对于我们应用程序而言，它仍然是同步，因为应用程序依然要等待i/o完全
	返回，cpu要么处于不停轮询状态，要么休眠等待事件发生，结论是它不够好。
	
	我们期待的完美的异步I/O应该是有应用程序发起非阻塞调用，然后直接处理下一任务，只需要在i/o完成后通过信号或者回调将
	数据传递给应用程序即可。linux原生提供了一个异步i/o方式也叫AIO就是通过信号或者回调函数来传递数据的，但还有部分缺陷。
	我们可以通过让部分线程进行非阻塞调用加轮询来完成数据获取，让一个线程进行计算处理（其实就是线程池），通过线程之间的
	通信将i/o得到的数据进行传递，这样就实现了异步i/o。nodejs在linux平台下采用了libeio配合libev实现异步i/o,其实质就是线程
	池与阻塞i/o模拟异步i/o.window下通过iocp,它在某种程度上提供了理想的异步i/o:调用异步方法，等待i/o完成后的通知，执行回调
	，用户无需考虑轮询。但是它的内部依然是线程池原理，不同之处在于这些线程池是由系统内核接受处理。由于window和*nix平台
	的差异，Node采用了libuv作为抽象封装层（我将其称为门面模式层）使得所有平台兼容性判断处理都由它来完成，并保证node和
	下层的自定义线程池以及iocp各自独立。
	
	
Node异步io怎么玩儿：

	
	

